
# Commented analysis of the hspc cells vs the prog cells. 

# This will be build on in each workshop and can be used as a template to
#   examine other comparisons. 


library(tidyverse)
library(readxl)
library(dplyr)
library(DESeq2)
library(ggrepel)
library(conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(GenomicRanges::setdiff)

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("scran")
library(scran)

BiocManager::install("biomaRt")
library(biomaRt)


# STEM CELLS. 

hspc <- read_csv("data-raw/surfaceome_hspc.csv")
prog <- read_csv("data-raw/surfaceome_prog.csv")

# Loads the datasets and stores as variables.


hspc_prog <- hspc %>%
  left_join(prog,
            by = "ensembl_gene_id")
hspc_prog

# Joins the two datasets together by the shared variable "ensemble_gene_id".


# DISTRIBUTION OF VALUES ACROSS ALL THE DATA IN THE FILE.

hspc_prog %>%
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") %>%
  ggplot(aes(x = expr)) +
  geom_histogram()

# These results are already logged, so no need to log10 this time. 


# DISTRIBUTION OF VALUES ACROSS THE SAMPLES. 

hspc_prog_summary_cell <- hspc_prog %>%
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") %>%
  group_by(cell) %>%
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_above_zero = sum(expr > 0))
hspc_prog_summary_cell

# Min value of 0 is in all 1,499 cells. 
# All lowerq values are 0. 
# Many median values are 0. 

# Use a ggplot w/ geom_pointrange() to show distribution of expressions
#   in cells. 
# pointrange puts a dot at the mean and a line bw- a min and a max 
#   such as 1 s.d. 

hspc_prog_summary_cell %>%
  ggplot(aes(x = cell, y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, 
                      ymax = mean + sd),
                  size = 0.1)

# Average expression in cells is similar for all cells. Good to know because
#   if some cells had much lower expression perhaps there is something wrong 
#   with them.
# The distributions are roughly similar in width too. 


hspc_prog_summary_cell %>%
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd,
                      ymax = mean + sd),
                  size = 0.1)

# reorder() arranges 'cell' in increasing size of 'mean'. 

# Results show that the distributions are similar across cells - not any
#   cells that are obviously different from the others (only incrementally). 


# DISTRIBUTION OF VALUES ACROSS THE GENES.

# Summarising the genes.
# Need to group by 'ensembl_gene_id' rather than 'cell'.
# sum(expr) finds the total expression in a gene.

hspc_prog_summary_gene <- hspc_prog %>%
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") %>%
  group_by(ensembl_gene_id) %>%
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_above_zero = sum(expr > 0))
hspc_prog_summary_gene  

# Lots of 0s on min - all 0s?
# Some genes (7) were expressed in every cell, many expressed in most. 
# Quite a few genes with 0 in many cells - this matters less when we have 
#   many cells (samples) than when we have few samples. 
# No genes with 0s in every cell - lowest no. of cells = 15. 


# Plotting the logged mean counts for each gene in order of size:

hspc_prog_summary_gene %>%
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd,
                      ymax = mean + sd),
                  size = 0.1)

# The variability between genes (average expression bw- 0.020 and 9.567)
#   is far greater than bw- cells (average expr bw- 1.319 and 9.567)
#   which is what we would expect. 






# FILTERING FOR QC. 

# No genes are visible in this dataset that are not expressed in any 
#   of the cells because we are using a specific subset of the transcriptome 
#   that was deliberately selected. 
#   = Unexpressed genes have been filtered out.

# But, good practice = verify there are no unexpressed genes before analysis.

# Where sum of all values  in the rows = 0, all entries must be 0. 
# This can be used to find any genes not expressed in any of the cells. 

# Row wise aggregates such as the sum across rows can be done w/ rowwise().

# c_across() allows colon notations to select columns. 
# Very useful with a lot of columns (don't have to list them all). 


# Find the genes that are 0 in every column of the hspc_prog dataframe:

hspc_prog %>%
  rowwise() %>%
  filter(sum(c_across(HSPC_001:Prog_852)) == 0)

# There are no rows produced when checking for 0 values,
#   which means that no genes are unexpressed in this dataset. 

# Filtered for the sum of c_across variables that are 0. 


# Write filtered data to file:

write_csv(hspc_prog,
          file = "data-processed/hspc_prog.csv")









# WORKSHOP 2: STATISTICAL/DIFFERENTIAL EXPRESSION ANALYSIS.


# Steps we will take:

# 1. Find the genes that are expressed in only one cell type (the prog
#   or the hspc).
# 2. Prepare the data for differential expression analysis with the scran
#   package. 
# 3. Do differential expression analysis on the genes using the scran package.
#   This needs to be done on the logged normalised counts. 



# 1. GENES EXPRESSED IN ONE CELL TYPE.

# Genes expressed in only one cell type are those with 0s in all the cells
#   of the other type. 
# To find them in this case, we sum the expression values for each gene
#   across the cells of one type and filter for those that are 0. 

# We use rowwise() to do row wise aggregates such as the sum across rows. 
# c_across() allows for colon notation to select columns. 
# ^ useful when there are lots of columns (see below). 


hspc_prog_only <- hspc_prog %>%
  rowwise() %>%
  filter(sum(c_across(HSPC_001:HSPC_852)) == 0)
hspc_prog_only

# This produces the genes expressed only in progenitor cells (those that are
#   0 in every HSPC cell). 

# 0 genes are expressed only in the progenitor cells. 


hspc_prog_hspc_only <- hspc_prog %>% 
  rowwise() %>% 
  filter(sum(c_across(Prog_001:Prog_852)) == 0)
hspc_prog_hspc_only

# 0 genes are expressed only in the HSPC cells. 


# In terms of the biology, when there are many replicates, it is less likely
#   that a gene will be expressed in only one group. 
# It's more likely that a gene will be expressed in both groups but at 
#   different levels. 
# Domain expertise is important when analysing data. 


write_csv(hspc_prog_hspc_only, "results/hspc_prog_hspc_only.csv")
write_csv(hspc_prog_only, "results/hspc_prog_only.csv")

# Saves the one-gene-only datasets as csv files in results. 



# 2. PREPARE THE DATA FOR ANALYSIS WITH SCRAN.

# scran can use a matrix or df of counts but these MUST BE log normalised
#   counts. 
# If using a df, cols MUST only contain the expr values (not the gene ids).
# Rows can be named to retain the gene ids. 

# hspc_prog = a df, so we will use the ensembl gene ids to name the rows
#   and remove the gene ids from the df. 


hspc_prog <- hspc_prog |>
  column_to_rownames("ensembl_gene_id")
hspc_prog

# Adds the gene ids as the row names. 


# Like DESeq2, scran needs metadata to define which cols were in which group.
# We create a vector that indicates which col belongs to which cell type. 


n_hspc <- 701
n_prog <- 798

cell_type <- rep(c("hspc","prog"), 
                 times = c(n_hspc, n_prog))
cell_type

# The number of times each cell type is repeated is the number of cells of 
#   that type. 
# The length of the cell_type vector should be the same length of the 
#   number of columns in the hspc_prog df. 




# 3. DIFFERENTIAL EXPRESSION ANALYSIS. 

# Loads the scran package. 
# These was inserted in the starting loading at the top too:

# if (!require("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
# BiocManager::install("scran")


# findMarkers() is used for diff. expr. 
# 2 arguments: the df and the vector stating which cols are in which cell type.

# The order of the cell types in the vector is appropriate for the order of 
#   the cols in the df. 


results_hspc_prog <- findMarkers(hspc_prog, 
                                 cell_type)
results_hspc_prog

# Runs the diff. expr. analysis. 
# Output = a list object which includes 2 dfs. 
#          - Not necessary as the results are the same except for the fold 
#               change having a different sign. 

results_hspc_prog$prog

# The df results_hspc_prog$prog is log prog - log hspc (i.e., Prog/HSPC). 
# This means:
# Pos fold change = prog > hspc. 
# Neg fold change = hspc > prog. 


results_hspc_prog$hspc

# This is log hspc - log prog.
# This means:
#   Pos fold change = hspc > prog. 
#   Neg fold change = prog > hspc. 


# We only need to keep one - doesn't matter which, just keep in mind the 
#   direction of the foldchange when interpreting the results. 

# Notice: the dfs are in order of significance rather than original gene order.


hspc_prog_results <- data.frame(results_hspc_prog$prog,
                                ensembl_gene_id = 
                                  row.names(results_hspc_prog$prog))
hspc_prog_results

# This extracts the results df from the list object and adds gene ids as col. 


hspc_prog <- hspc_prog %>%
  rownames_to_column(var = "ensembl_gene_id")
hspc_prog

# Returns the ensembl gene ids as a col to the normalised counts. 


hspc_prog_results <- hspc_prog_results %>%
  left_join(hspc_prog, by = "ensembl_gene_id")
hspc_prog_results



# Gene information can then be added: 

# Ensure that the biomaRt package is installed at the top and load the package.


ensembl <- useMart(biomart = "ensembl",
                     dataset = "mmusculus_gene_ensembl")
ensembl

# This connects to the mouse database.


listAttributes(mart = ensembl) %>%
  View()

# This displays the information that we can retrieve. 

# 2,988 possible bits of information with 3 columns. 


gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = hspc_prog_results$ensembl_gene_id,
                   mart = ensembl)
gene_info

# Above gets the gene name, description, and the gene id so we can alter 
#   join the information with the results. 

# getBM() = retrieves information from the database. 
# filters = specifies what kind of identifier we are supplying in values
#   to retrieve information. 
# attributes argument selects the information we want to retrieve. 
# values argument specifies the identifiers. 
# mart argument specifies the connection we created. 


hspc_prog_results <- hspc_prog_results %>%
  left_join(gene_info, by = "ensembl_gene_id")

# Merges the gene information with the results. 


write_csv(hspc_prog_results, file = "results/hspc_prog_results.csv")

# Saves the results to a csv file in the results folder. 









# WORKSHOP 3: VISUALISING AND INTERPRETING. 

# Conducting PCA (Principal Component Analysis) and a nicely-formatted 
#    Volcano plot. 
# Significant genes will be saved to file to make it easier to identify 
#   genes of interest.

glimpse(hspc_prog_results)

# 1,500 rows, 280 columns. 


# No need to load metadata this time = cell types encoded into col names.

# No need to log2 transform - already done. 




# WRITE THE SIGNIFICANT GENES TO FILE. 

hspc_prog_results_sig0.05 <- hspc_prog_results %>%
  filter(FDR <= 0.05)
hspc_prog_results_sig0.05

# padj has been changed to FDR, remember:
#    "padj" in the DESeq2 output. 
#    "FDR" in the scran output. 

# 182 genes that are significant at the 0.05 level. 

write_csv(hspc_prog_results_sig0.05,
          file = "results/hspc_prog_results_sig0.05.csv")

# Saves the hspc_prog_results_sig0.05 as a csv file in results folder. 




# PRINCIPAL COMPONENT ANALYSIS (PCA). 

hspc_prog_trans <- hspc_prog_results %>%
  dplyr::select(starts_with(c("HSPC_", "Prog_"))) %>%
  t() %>%
  data.frame()
hspc_prog_trans

# Selects for results starting with either "HSPC_" or "Prog_".
# t() transforms. 
# Sets into a df. 
# Sets as hspc_prog_trans. 

colnames(hspc_prog_trans) <- hspc_prog_results$ensembl_gene_id
colnames(hspc_prog_trans)

# Sets col names as gene ids. 

pca <- hspc_prog_trans %>%
  prcomp(rank. = 8)
pca

summary(pca)

# Performs a PCA on the log2 transformed normalised counts.
# This runs for 8 principal components. 

# Summary produces sd's, prop. of var., and cum. prop.

pca_labelled <- data.frame(pca$x,
                           cell_id = row.names(hspc_prog_trans))
pca_labelled

# Creates dataframe of PCA scores from PC1 and PC2, also adds cell_id col of 
#   the row names. 

pca_labelled <- pca_labelled %>%
  extract(cell_id, 
          remove = FALSE,
          c("cell_type", "cell_number"),
          "([a-zA-Z]{4})_([0-9]{3})")
pca_labelled

# Extracts the cell type and cell number from the cell_id col, keeping that col.
# It takes what's in cell_id col and splits into 2 cols "cell_type" and 
#    "cell_number".
#    We do this because we're colouring by cell type.
#    We don't want to use cell_id to colour points because each cell id is 
#       unique and that would be 1,000+ colours. 

# Last argument in extract() is pattern to match described w/ a regular 
#    expression. 
# 3 patterns are being matched - 2 are in brackets meaning that they are
#    kept to fill the 2 new cols. 

# First pattern = ([a-zA-Z]{4})
# - Brackets - because we want to keep it and put it in cell_type.
# - [1-zA-Z] - any lower or upper case letter. 
# - Square brackets - any chars inside will be matched. 
# - {4} - 4 of them.
# So the first pattern inside the first () will match exactly 4 upper or lower
#    case letters (e.g., Prog, HSPC). 

# Second pattern = _
# - Matches the underscore in every cell id that separates cell type from no. 
# - Not in brackets because we don't want to keep it. 

# Third pattern = ([0-9]{3})
# - [0-9] - means any number. 
# - {3} - means 3 of them. 
# - So the second pattern will match exactly 3 numbers (e.g., 001, 851).

# IMPORTANT!!
# For col names LT.HSPC, this has 6 chars with a dot. Be careful here. 
# The pattern to match LT.HSPC, Prog, and HSPC = ([a-zA-Z.]{4, 6}) 

pca_labelled %>%
  ggplot(aes(x= PC1, y = PC2,
             colour = cell_type)) +
  geom_point(alpha = 0.4) +
  theme_classic()

# Two general clusters can be seen here. Distinct colours really help. 
# Plenty of overlap though. 

pca_labelled %>%
  ggplot(aes(x = PC3, y = PC4,
             colour = cell_type)) +
  geom_point(alpha = 0.4) +
  theme_classic()

# The datapoints are even more overlapped in PC3 and PC4 comparison.

pca_labelled %>%
  ggplot(aes(x = PC1, y = PC2,
             colour = cell_type)) +
  geom_point(alpha = 0.4) +
  scale_colour_viridis_d(end = 0.95, begin = 0.15,
                         name = NULL) +
  theme_classic()

# This plots PC2 against PC1, and colour by cell type. 
# Different colours this time.
# Two clear clusters but still significant overlap. 




# VISUALISE ALL THE RESULTS WITH A VOLCANO PLOT. 

hspc_prog_results <- hspc_prog_results %>%
  mutate(log10_FDR = -log10(FDR))
hspc_prog_results

# Takes hspc_prog_results df and adds in col for log10_FDR. 

hspc_prog_results %>%
  ggplot(aes(x = summary.logFC,
             y = log10_FDR)) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = 2,
             linetype = "dashed") +
  geom_vline(xintercept = -2,
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() +
  theme(legend.position = "none")

# Plots a volcano plot for the results. 

hspc_prog_results <- hspc_prog_results %>%
  mutate(sig = FDR <= 0.05,
         bigfc = abs(summary.logFC) >= 2)
hspc_prog_results             

# Takes hspc_prog_results and adds cols for sig and bigfc. 

hspc_prog_results %>%
  ggplot(aes(x = summary.logFC,
             y = log10_FDR,
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = 2,
             linetype = "dashed") +
  geom_vline(xintercept = 2,
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("grey",
                                 "pink",
                               # "grey30",
                                 "deeppink")) +
  theme_classic() +
  theme(legend.position = "none")

# Produces a volcano plot. Only 3 colours are needed so grey30 is commented.

hspc_prog_results %>%
  ggplot(aes(x = summary.logFC,
             y = log10_FDR,
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = 2,
             linetype = "dashed") +
  geom_vline(xintercept = -2,
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("grey",
                                 "pink",
                               # "grey30",
                                 "deeppink")) +
  geom_text_repel(data = hspc_prog_results %>%
                    filter(bigfc == TRUE, sig == TRUE), 
                  aes(label = external_gene_name),
                  size = 3,
                  max.overlaps = 50) +
  theme_classic() +
  theme(legend.position = "none")

# This volcano plot adds labels to the datapoints/values that are:
# > 0.05 for log10_FDR
# > 2 for summary.logFC
# < -2 for summary.logFC

# So only the data that is significant and with large fold changes have been
#   labelled. 

# Remember:
# - Pos fold change = up-regulation of Prog.
# - Neg fold change = down-regulation of Prog (higher in HSPC). 

# Forgot which way around the comparison is?
# Examine gene summary dataframe to see which of the treatments seem to be 
#   higher for the pos fold changes. 

hspc_prog_results %>%
  ggplot(aes(x = summary.logFC,
             y = log10_FDR,
             colour = interaction(sig, bigfc))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = 2,
             linetype = "dashed") +
  geom_vline(xintercept = -2,
             linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("grey",
                                 "pink",
                               # "grey30",
                                 "deeppink")) +
  geom_label_repel(data = hspc_prog_results %>%
                     filter(external_gene_name == "Procr"),
                   aes(label = external_gene_name), 
                   size = 4,
                   nudge_x = .5,
                   nudge_y = 1.5) +
  geom_point(data = hspc_prog_results %>%
               filter(external_gene_name == "Procr"),
             size = 3) +
  theme_classic() + 
  theme(legend.position = "none")

# This volcano plot labels only one specific gene of interest. 

# To label more than one specific gene of interest:

# filter(external_gene_name %in% c("Procr", "Emb"))




# SAVING PLOTS.

ggsave("figures/hspc_prog_results.png",
       height = 4.5,
       width = 4.5,
       units = "in",
       device = "png")














